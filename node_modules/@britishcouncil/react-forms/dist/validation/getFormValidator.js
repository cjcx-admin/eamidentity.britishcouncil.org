import {
    get
} from 'lodash-es';
import {
    set
} from 'lodash-es';
import {
    generateObjectPaths
} from '@britishcouncil/common-core';
import validateEqual from './validators/validateEqual';
import validateGreater from './validators/validateGreater';
import validateGreaterOrEqual from './validators/validateGreaterOrEqual';
import validateLessOrEqual from './validators/validateLessOrEqual';
import validateLess from './validators/validateLess';
import validateLength from './validators/validateLength';
import validateNotEqual from './validators/validateNotEqual';
import validateRegex from './validators/validateRegex';
import validateRequired from './validators/validateRequired';
import {
    mapToRulesFieldName
} from './utils';
const validationFunctions = new Map([
    ['required', validateRequired],
    ['equal', validateEqual],
    ['notEqual', validateNotEqual],
    ['greaterThan', validateGreater],
    ['greaterThanOrEqual', validateGreaterOrEqual],
    ['lessThan', validateLess],
    ['lessThanOrEqual', validateLessOrEqual],
    ['length', validateLength],
    ['regex', validateRegex],
]);
const validationMessages = new Map([
    ['required', 'This field is required.'],
    ['equal', 'This field value needs be equal to other value.'],
    ['notEqual', 'This field value needs be different than other value.'],
    ['greaterThan', 'This field value is below the minimum.'],
    ['greaterThanOrEqual', 'This field value is below the minimum.'],
    ['lessThan', 'This field value is above the maximum.'],
    ['lessThanOrEqual', 'This field value is above the maximum.'],
    ['length', 'This field value has invalid length.'],
    ['regex', 'This field does not match supplied pattern.'],
]);
const getFieldValidator = (formValues) => {
    return (fieldName, rules) => {
        const value = get(formValues, fieldName);
        return Object.entries(rules).reduce((result, [ruleName, rule]) => {
            const validationFn = validationFunctions.get(ruleName);
            if (!validationFn) {
                console.warn(`Could not find validation function for "${ruleName}". Fields with this type won't be validated.`);
                return result;
            }
            if (validationFn(value, rule, formValues)) {
                return result;
            }
            const message = rule.message || validationMessages.get(ruleName);
            return result.isValidated ?
                {
                    isValidated: false,
                    message
                } :
                { ...result,
                    message: `${result.message}\n${message}`
                };
        }, {
            isValidated: true
        });
    };
};
const getFormValidator = (rules) => (sectionName, skippedFields = []) => {
    const section = rules[sectionName];
    if (!section) {
        throw new Error(`Could not find section "${String(sectionName)}".`);
    }
    return (values) => {
        const validateField = getFieldValidator(values);
        const errors = {};
        for (const fieldPath of generateObjectPaths(values)) {
            const fieldRules = section.fields[mapToRulesFieldName(fieldPath)];
            if (!fieldRules) {
                continue;
            }
            if (skippedFields.find(x => x === fieldPath)) {
                continue;
            }
            const result = validateField(fieldPath, fieldRules.rules);
            if (!result.isValidated) {
                set(errors, fieldPath, result.message);
            }
        }
        return errors;
    };
};
export default getFormValidator;