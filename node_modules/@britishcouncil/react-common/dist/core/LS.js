function isString(x) {
    return Object.prototype.toString.call(x) === '[object String]';
}
/**
 * Local Storage Wrapper. Will persist contents forever. It's as simple as it gets.
 **/
export const SimpleLS = {
    /**
     * Read a typed object from the local storage
     *
     * @template T
     * @param {string} key
     * @param {any} defaultValue Value to be returned when localStorage does not contain requested key
     * @returns {T}
     */
    read(key, defaultValue = undefined) {
        const value = localStorage.getItem(key);
        if (!value) {
            return defaultValue;
        }
        try {
            const item = JSON.parse(value);
            return item;
        } catch (error) {
            return value || defaultValue;
        }
    },
    /**
     * Write complex object or string to the local storage
     *
     * @param {string} key
     * @param {string} value
     * @param {string} ttl (s) define how long this value can be used. Does not work with `string` type
     */
    write(key, value) {
        let val = value;
        const text = isString(value) ? value : JSON.stringify(val);
        try {
            localStorage.setItem(key, text);
        } catch (err) {
            if (err instanceof Error && err.name === 'NS_ERROR_FILE_CORRUPTED') {
                localStorage.clear();
            }
        }
    },
    /**
     * Remove selected item from the local storage
     *
     * @param {string} key
     */
    remove(key) {
        localStorage.removeItem(key);
    },
};
/** Session Storage Wrapper. Will persist contents as long as tab is not closed */
export const SS = {
    /**
     * Read a typed object from the session storage
     *
     * @template T
     * @param {string} key
     * @param {any} defaultValue Value to be returned when sessionStorage does not contain requested key
     * @returns {T}
     */
    read(key, defaultValue = undefined) {
        const value = sessionStorage.getItem(key);
        if (!value) {
            return defaultValue;
        }
        try {
            return JSON.parse(value);
        } catch (error) {
            return value || defaultValue;
        }
    },
    /**
     * Write complex object or string to the session storage
     *
     * @param {string} key
     * @param {string} text
     */
    write(key, value) {
        const text = isString(value) ? value : JSON.stringify(value);
        try {
            sessionStorage.setItem(key, text);
        } catch (err) {
            if (err instanceof Error && err.name === 'NS_ERROR_FILE_CORRUPTED') {
                sessionStorage.clear();
            }
        }
    },
    /**
     * Remove selected item from the session storage
     *
     * @param {string} key
     */
    remove(key) {
        sessionStorage.removeItem(key);
    },
};
/**
 * Local Storage Wrapper. Will persist contents for longer and it's quite robust to
 * define when stored values will be invalidated. You can add expiry time and/or token.
 * Token can be bound to app version, or something similar. And when it changes then
 * it invalidates stored data
 **/
export const AdvancedLS = {
    /**
     * Read a typed object from the local storage
     *
     * @template T
     * @param {string} key
     * @param opts
     * @param {any} defaultValue Value to be returned when localStorage does not contain requested key
     * @returns {T}
     */
    read(key, opts, defaultValue = undefined) {
        const value = localStorage.getItem(key);
        if (!value) {
            return defaultValue;
        }
        try {
            const item = JSON.parse(value);
            if (item && !!item.value) {
                if (!!item.expiry && new Date().getTime() > item.expiry) {
                    localStorage.removeItem(key);
                    return defaultValue;
                }
                if ((item.token || opts.cacheToken) && item.token !== opts ? .cacheToken) {
                    localStorage.removeItem(key);
                    return defaultValue;
                }
                return item.value;
            }
            return defaultValue;
        } catch (error) {
            return value || defaultValue;
        }
    },
    /**
     * Write complex object or string to the local storage
     *
     * @param {string} key
     * @param {string} value
     * @param {string} opts Options defining how long this data can live
     */
    write(key, value, opts) {
        const val = {
            value
        };
        if (opts ? .ttl) {
            val.expiry = new Date().getTime() + opts.ttl * 1000;
        }
        if (opts ? .cacheToken) {
            val.token = opts.cacheToken;
        }
        try {
            localStorage.setItem(key, JSON.stringify(val));
        } catch (err) {
            if (err instanceof Error && err.name === 'NS_ERROR_FILE_CORRUPTED') {
                localStorage.clear();
            }
        }
    },
    /**
     * Remove selected item from the local storage
     *
     * @param {string} key
     */
    remove(key) {
        localStorage.removeItem(key);
    },
};