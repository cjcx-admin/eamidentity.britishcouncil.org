import React, {
    useCallback,
    useEffect,
    useMemo,
    useRef,
    useState
} from 'react';
import {
    useClickOutside
} from '@britishcouncil/react-common';
import {
    FiChevronDown,
    FiLoader
} from 'react-icons/fi';
import {
    Checkbox
} from '../checkbox';
import {
    Radio
} from '../radio';
import * as S from './Filter.style';
import {
    FindIcon,
    RemoveIcon
} from '../../icons';
export const Filter = ({
    autoClose = false,
    autoFocus = false,
    allOptionsLabel,
    applyButtonLabel,
    children,
    customWidth,
    background,
    defaultSelectLabel = 'select',
    disableApply,
    disableReset,
    elements,
    filterLabel,
    filterPlaceholder = 'Search filters',
    initialValues = [],
    isLoading,
    onApply,
    onOpen,
    onChange,
    onChangeSingleValue,
    onReset,
    maxHeight,
    resetButtonLabel,
    resetDirection = 'all',
    search = false,
    variant = 'default',
    type = 'multiSelect',
    values,
    ...rest
}) => {
    const ref = useRef(null);
    const refTrigger = useRef(null);
    const [opened, setOpened] = useState(false);
    const [filterBy, setFilterBy] = useState('');
    const allRef = useRef();
    const applyRef = useRef();
    const optionsLIRef = useRef([]);
    const resetRef = useRef();
    const searchRef = useRef();
    const [currentValues, setCurrentValues] = useState(elements.map((el) => {
        return {
            element: el,
            selected: initialValues.includes(el.value),
        };
    }));
    const currentDisplayedValues = useMemo(() => {
        optionsLIRef.current = [];
        return currentValues.filter((el) => el.element.value.search(filterBy.toLowerCase()) !== -1 ||
            el.element.label.toLowerCase().search(filterBy.toLowerCase()) !== -1);
    }, [currentValues, filterBy]);
    const checkedCount = useMemo(() => {
        return currentValues.length - currentValues.filter((el) => !el.selected).length;
    }, [currentValues]);
    const allChecked = useMemo(() => {
        return currentValues.filter((el) => !el.selected || el.element.disabled).length === 0;
    }, [currentValues]);
    const filterText = useMemo(() => {
        const firstElement = currentValues.find((el) => !el.element.disabled && el.selected);
        const firstValue = firstElement ? .element.label ? ? firstElement ? .element.value;
        return allChecked && allOptionsLabel ? allOptionsLabel : firstValue || defaultSelectLabel;
    }, [allChecked, allOptionsLabel, currentValues, defaultSelectLabel]);
    useEffect(() => {
        if (values) {
            setCurrentValues(elements.map((el) => {
                return {
                    element: el,
                    selected: values.includes(el.value),
                };
            }));
        }
    }, [elements, values]);
    useClickOutside(ref, () => setOpened(false), refTrigger, () => setOpened(!opened));
    useEffect(() => {
        if (onOpen)
            onOpen(opened);
        if (opened && autoFocus) {
            focusAtFirst();
        }
    }, [opened, onOpen, autoFocus]);
    const handleApply = useCallback(() => {
        if (onApply) {
            onApply(currentValues.filter((el) => el.selected).map((el) => el.element.value));
            closeDropdown();
        }
    }, [currentValues, onApply]);
    const handleClick = useCallback((value, isReset) => {
        let newSet = currentValues ? .map((filter) => {
            if (filter.element.disabled) {
                return filter;
            }
            if (type === 'singleSelect') {
                filter.selected = false;
            }
            if (filter.element.value === value) {
                filter.selected = !filter.selected;
            }
            if (value === 'none' || value === 'all') {
                filter.selected = value === 'all' && !allChecked;
            }
            return filter;
        });
        onChange && onChange(newSet.filter((el) => el.selected).map((el) => el.element.value));
        onChangeSingleValue && onChangeSingleValue(value);
        if (!values)
            setCurrentValues(newSet);
        if (isReset) {
            onReset && onReset();
            onApply && onApply(newSet.filter((el) => el.selected).map((el) => el.element.value));
            setFilterBy('');
            closeDropdown();
        }
        autoClose && closeDropdown();
    }, [allChecked, autoClose, currentValues, onChange, onChangeSingleValue, onReset, type, values]);
    const handleTriggerKeyDown = useCallback((event) => {
        switch (event.key) {
            case ' ':
            case 'Enter':
            case 'SpaceBar':
                event.preventDefault();
                event.stopPropagation();
                setOpened(!opened);
                focusAtFirst();
                break;
            case 'ArrowDown':
                event.preventDefault();
                event.stopPropagation();
                if (!opened) {
                    setOpened(true);
                } else {
                    focusAtFirst();
                }
                break;
            default:
                break;
        }
    }, []);
    const getListRefs = useCallback(() => {
        const values = currentDisplayedValues.map((el) => el.element.value);
        const visibleList = optionsLIRef.current.filter((el) => values.includes(el.id));
        const currentElementIndex = visibleList.findIndex((el) => el === document.activeElement);
        return {
            currentElementIndex,
            visibleList
        };
    }, [currentDisplayedValues]);
    const handleListKeyDown = useCallback((event) => {
        const {
            currentElementIndex,
            visibleList
        } = getListRefs();
        const {
            isReset,
            isApply,
            isAll,
            orderedList,
            orderedListIndex
        } = getCurrentRefs(visibleList);
        switch (event.key) {
            case ' ':
            case 'Enter':
            case 'SpaceBar':
                event.preventDefault();
                isAll && handleClick('all');
                isApply && handleApply();
                isReset && !disableReset && !(allChecked && resetDirection === 'all') && handleClick(resetDirection, true);
                currentElementIndex !== -1 && handleClick(currentDisplayedValues[currentElementIndex].element.value);
                break;
            case 'Escape':
                closeDropdown();
                break;
            case 'ArrowUp':
                event.preventDefault();
                if (orderedList[orderedListIndex - 1]) {
                    orderedList[orderedListIndex - 1].focus();
                } else {
                    closeDropdown();
                }
                break;
            case 'ArrowDown':
                event.preventDefault();
                if (orderedList[orderedListIndex + 1]) {
                    orderedList[orderedListIndex + 1].focus();
                } else {
                    closeDropdown();
                }
                break;
            default:
                break;
        }
    }, [getListRefs, handleClick, handleApply, resetDirection, currentDisplayedValues]);
    const closeDropdown = () => {
        ref.current ? .blur();
        setOpened(false);
        refTrigger.current && refTrigger.current.focus();
    };
    const focusAtFirst = () => {
        if (searchRef.current) {
            searchRef.current.focus();
        } else if (allRef.current) {
            allRef.current.focus();
        } else {
            optionsLIRef.current[0] && optionsLIRef.current[0].focus();
        }
    };
    const getCurrentRefs = (visibleList) => {
        const isAll = allRef.current === document.activeElement;
        const isApply = applyRef.current === document.activeElement;
        const isReset = resetRef.current === document.activeElement;
        const orderedList = [...visibleList];
        allRef.current && orderedList.unshift(allRef.current);
        searchRef.current && orderedList.unshift(searchRef.current);
        applyRef.current && orderedList.push(applyRef.current);
        resetRef.current && orderedList.push(resetRef.current);
        const orderedListIndex = orderedList.findIndex((el) => el === document.activeElement);
        return {
            isReset,
            isApply,
            isAll,
            orderedList,
            orderedListIndex
        };
    };
    return (React.createElement(S.FilterWrapper, {
            ref: ref,
            ...rest,
            opened: opened,
            onKeyDown: handleListKeyDown
        },
        filterLabel && React.createElement(S.FilterLabel, null, filterLabel),
        React.createElement(S.FilterTrigger, {
                background: background,
                ref: refTrigger,
                tabIndex: 0,
                onKeyDown: handleTriggerKeyDown,
                "data-testid": "filterTrigger"
            }, !allChecked && checkedCount > 0 && type !== 'singleSelect' && (React.createElement(S.FilterCounter, null,
                checkedCount,
                ' ',
                React.createElement(S.FilterCleaner, {
                        onClick: () => handleClick('none', true)
                    },
                    React.createElement(RemoveIcon, null)))), !allChecked && checkedCount > 0 && (React.createElement(S.FilterTriggerHoverText, {
                    className: "filterTriggerHoverText"
                },
                filterText,
                React.createElement("svg", {
                        xmlns: "http://www.w3.org/2000/svg",
                        width: "22",
                        height: "18",
                        viewBox: "0 0 22 18",
                        fill: "none"
                    },
                    React.createElement("path", {
                        d: "M11 18L0.607697 0L21.3923 0L11 18Z",
                        fill: "#005CB9"
                    })))),
            React.createElement(S.FilterTriggerText, {
                wide: type === 'singleSelect'
            }, filterText),
            React.createElement(S.FilterTriggerArrow, {
                    opened: opened
                },
                React.createElement(FiChevronDown, {
                    size: 24,
                    stroke: "#898A8D"
                }))),
        opened && (React.createElement(React.Fragment, null,
            isLoading && (React.createElement(S.FilterLoader, {
                    customWidth: customWidth
                },
                React.createElement(FiLoader, {
                    size: 20
                }))), !isLoading && (React.createElement(S.FilterListWrapper, {
                    customWidth: customWidth
                },
                search && (React.createElement(S.FilterSearchWrapper, {
                        last: !applyButtonLabel && !allOptionsLabel && !resetButtonLabel && currentDisplayedValues.length === 0,
                        variant: variant
                    },
                    React.createElement("input", {
                        type: "text",
                        onChange: (e) => {
                            setFilterBy(e.target.value);
                        },
                        placeholder: filterPlaceholder,
                        ref: (el) => {
                            if (el)
                                searchRef.current = el;
                        },
                        value: filterBy,
                        tabIndex: 0
                    }),
                    React.createElement(S.FilterSearchIcon, null,
                        React.createElement(FindIcon, null)))),
                React.createElement(S.FilterList, {
                        maxHeight: maxHeight
                    },
                    allOptionsLabel && (React.createElement(S.FilterElement, {
                            checked: allChecked,
                            "data-testid": 'all',
                            key: 'all',
                            variant: variant,
                            innerBorder: search,
                            onClick: () => {
                                handleClick('all');
                            },
                            ref: (el) => {
                                if (el)
                                    allRef.current = el;
                            },
                            tabIndex: 0
                        },
                        React.createElement(Checkbox, {
                            hideFrame: true,
                            onClick: (event) => event.stopPropagation(),
                            onChange: () => {},
                            label: allOptionsLabel,
                            value: allChecked,
                            tabIndex: -1
                        }))),
                    currentDisplayedValues.map(({
                        element: {
                            disabled,
                            label,
                            value
                        },
                        selected
                    }, index) => {
                        return (React.createElement(S.FilterElement, {
                            checked: selected,
                            disabled: disabled,
                            "data-testid": value ? ? label,
                            key: value,
                            variant: variant,
                            onClick: () => {
                                if (!disabled)
                                    handleClick(value);
                            },
                            inner: search || !!allOptionsLabel,
                            id: value,
                            ref: (el) => {
                                if (el)
                                    optionsLIRef.current[index] = el;
                            },
                            tabIndex: 0
                        }, type !== 'singleSelect' ? (React.createElement(Checkbox, {
                            disabled: disabled,
                            hideFrame: true,
                            label: label ? ? value,
                            onClick: (event) => event.stopPropagation(),
                            onChange: () => {},
                            tabIndex: -1,
                            value: selected
                        })) : (React.createElement(Radio, {
                            disabled: disabled,
                            hideFrame: true,
                            label: label ? ? value,
                            onClick: (event) => event.stopPropagation(),
                            onChange: () => {},
                            tabIndex: -1,
                            value: selected
                        }))));
                    })),
                type !== 'singleSelect' && (React.createElement(S.ButtonWrapper, null,
                    applyButtonLabel && (React.createElement(S.ButtonFilter, {
                        disabled: disableApply,
                        onClick: () => handleApply(),
                        ref: (el) => {
                            if (el)
                                applyRef.current = el;
                        },
                        tabIndex: 0,
                        variant: variant
                    }, applyButtonLabel)),
                    resetButtonLabel && (React.createElement(S.ButtonFilter, {
                        disabled: disableReset || allChecked,
                        onClick: () => !disableReset && !(allChecked && resetDirection === 'all') && handleClick(resetDirection, true),
                        tabIndex: 0,
                        ref: (el) => {
                            if (el)
                                resetRef.current = el;
                        },
                        variant: variant
                    }, resetButtonLabel))))))))));
};